# Workflow g√ºncellendi - 12 Eyl√ºl
# üîÑ Multi-Environment Deployment Workflow
# ... dosyanƒ±n geri kalanƒ± ...
# üîÑ Multi-Environment Deployment Workflow
# Professional CI/CD pipeline for Production, Staging, and Development environments
name: üöÄ Multi-Environment Deploy

on:
  push:
    branches: 
      - main        # ‚Üí Production
      - develop     # ‚Üí Staging
      - 'feature/*' # ‚Üí Development
      - 'hotfix/*'  # ‚Üí Production (emergency fixes)
  pull_request:
    branches: [main, develop]
  delete:
    # Fixed: Removed the nested 'branches' mapping that was causing the error
    
env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: us-central1
  DOCKER_REGISTRY: gcr.io
  SQLX_OFFLINE: true
  
jobs:
  # ========================================
  # 1. Environment Configuration
  # ========================================
  set-environment:
    name: üéØ Configure Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      service-name: ${{ steps.set-env.outputs.service-name }}
      should-deploy: ${{ steps.set-env.outputs.should-deploy }}
      is-ephemeral: ${{ steps.set-env.outputs.is-ephemeral }}
    steps:
    - id: set-env
      run: |
        # Default values
        SHOULD_DEPLOY="true"
        IS_EPHEMERAL="false"
        
        if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/hotfix/"* ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "service-name=todo-api" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "service-name=todo-api-staging" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
          # PR environments
          echo "environment=preview" >> $GITHUB_OUTPUT
          echo "service-name=todo-api-pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          IS_EPHEMERAL="true"
        else
          # Feature branch environments
          BRANCH_NAME=$(echo "${{ github.head_ref || github.ref_name }}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c1-40)
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "service-name=todo-api-dev-${BRANCH_NAME}" >> $GITHUB_OUTPUT
          IS_EPHEMERAL="true"
        fi
        
        # Don't deploy on PR unless it's a deployment PR
        if [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy-preview') }}" != "true" ]]; then
          SHOULD_DEPLOY="false"
        fi
        
        echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "is-ephemeral=$IS_EPHEMERAL" >> $GITHUB_OUTPUT
        
        # Log configuration
        echo "üìã Configuration Summary:"
        echo "  Environment: $(grep environment $GITHUB_OUTPUT | cut -d= -f2)"
        echo "  Service: $(grep service-name $GITHUB_OUTPUT | cut -d= -f2)"
        echo "  Should Deploy: $SHOULD_DEPLOY"
        echo "  Is Ephemeral: $IS_EPHEMERAL"

  # ========================================
  # 2. Tests & Quality Checks
  # ========================================
  test-and-quality:
    name: üß™ Tests & Quality
    runs-on: ubuntu-latest
    if: github.event_name != 'delete'
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: todo_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
    - uses: actions/checkout@v4
    
    - name: ü¶Ä Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
        
    - name: üì¶ Cache Dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-v2 
        restore-keys: |
          ${{ runner.os }}-cargo-
    - name: üîç Format Check
      run: cargo fmt -- --check
      
    - name: üìã Clippy Linting
      run: cargo clippy -- -D warnings
      
    - name: üîí Security Audit
      run: |
        cargo install cargo-audit --locked || true
        cargo audit || true  # Non-blocking for now

    - name: üßπ Clean Cargo Cache Before Tests
      run: cargo clean

    - name: üß™ Run Tests
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/todo_test
        JWT_SECRET: dGhpc19pc19hX3ZhbGlkX3Rlc3Rfc2VjcmV0X2tleV9mb3JfZ2l0aHViISE=
        HASHING_SECRET_KEY: test-hashing-secret-16-chars-min
        RUST_BACKTRACE: 1
      run: |
        cargo test --verbose --all-features
        cargo test --doc

  # ========================================
  # 3. Build & Deploy
  # ========================================
  deploy:
    name: üöÄ Build & Deploy
    runs-on: ubuntu-latest
    needs: [set-environment, test-and-quality]
    if: |
      github.event_name == 'push' && 
      needs.set-environment.outputs.should-deploy == 'true'
    environment: ${{ needs.set-environment.outputs.environment }}
    outputs:
      service_url: ${{ steps.get_url.outputs.url }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
    - uses: actions/checkout@v4
    
    - name: üîê Google Cloud Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: ‚öôÔ∏è Setup Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      
    - name: üîß Configure Docker
      run: gcloud auth configure-docker ${{ env.DOCKER_REGISTRY }}
      
    - name: üèóÔ∏è Build Docker Image
      id: build
      run: |
        IMAGE_NAME="${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}/${{ needs.set-environment.outputs.service-name }}"
        
        # Multi-stage build with cache
        docker build -f Dockerfile.production \
          -t $IMAGE_NAME:${{ github.sha }} \
          -t $IMAGE_NAME:latest \
          --cache-from $IMAGE_NAME:latest \
          --cache-from $IMAGE_NAME:builder \
          --build-arg BUILDKIT_INLINE_CACHE=1 \
          --target production \
          .
        
        # Get digest for security
        DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_NAME:${{ github.sha }} 2>/dev/null | cut -d'@' -f2 || echo "none")
        echo "digest=$DIGEST" >> $GITHUB_OUTPUT
        
    - name: üì§ Push Docker Image
      run: |
        IMAGE_NAME="${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}/${{ needs.set-environment.outputs.service-name }}"
        docker push $IMAGE_NAME --all-tags
        
    - name: üöÄ Deploy to Cloud Run
      id: deploy
      run: |
        SERVICE_NAME="${{ needs.set-environment.outputs.service-name }}"
        IMAGE_NAME="${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}/$SERVICE_NAME:${{ github.sha }}"
        ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
        
        # Environment-specific configurations
        case "$ENVIRONMENT" in
          production)
            MEMORY="512Mi"
            CPU="1"
            MIN_INSTANCES="0"
            MAX_INSTANCES="10"
            CONCURRENCY="80"
            LOG_LEVEL="info"
            SECRETS="--set-secrets=DATABASE_URL=database-url:latest,JWT_SECRET=jwt-secret:latest,HASHING_SECRET_KEY=hashing-secret:latest"
            LABELS="env=production,team=backend,cost-center=engineering"
            ;;
          staging)
            MEMORY="512Mi"
            CPU="1"
            MIN_INSTANCES="0"
            MAX_INSTANCES="5"
            CONCURRENCY="80"
            LOG_LEVEL="debug"
            SECRETS="--set-secrets=DATABASE_URL=database-url-staging:latest,JWT_SECRET=jwt-secret-staging:latest,HASHING_SECRET_KEY=hashing-secret-staging:latest"
            LABELS="env=staging,team=backend"
            ;;
          preview)
            MEMORY="256Mi"
            CPU="0.5"
            MIN_INSTANCES="0"
            MAX_INSTANCES="3"
            CONCURRENCY="50"
            LOG_LEVEL="debug"
            SECRETS=""  # Use env vars for PR previews
            LABELS="env=preview,pr=${{ github.event.pull_request.number }},ephemeral=true"
            ;;
          *)
            MEMORY="256Mi"
            CPU="0.5"
            MIN_INSTANCES="0"
            MAX_INSTANCES="2"
            CONCURRENCY="50"
            LOG_LEVEL="trace"
            SECRETS=""  # Use env vars for dev
            LABELS="env=development,branch=${{ github.ref_name }},ephemeral=true"
            ;;
        esac
        
        # Add expiry label for ephemeral environments
        if [[ "${{ needs.set-environment.outputs.is-ephemeral }}" == "true" ]]; then
          EXPIRY_DATE=$(date -u -d "+7 days" +%Y-%m-%d)
          LABELS="$LABELS,expires=$EXPIRY_DATE"
        fi
        
        gcloud run deploy $SERVICE_NAME \
          --project=${{ env.PROJECT_ID }} \
          --image $IMAGE_NAME \
          --region ${{ env.REGION }} \
          --platform managed \
          --allow-unauthenticated \
          --port 8080 \
          --memory $MEMORY \
          --cpu $CPU \
          --min-instances $MIN_INSTANCES \
          --max-instances $MAX_INSTANCES \
          --concurrency $CONCURRENCY \
          --timeout 300 \
          --set-env-vars="GCP_PROJECT_ID=${{ env.PROJECT_ID }},RUST_LOG=$LOG_LEVEL,ENVIRONMENT=$ENVIRONMENT,DEPLOYED_BY=${{ github.actor }},COMMIT_SHA=${{ github.sha }}" \
          $SECRETS \
          --labels="$LABELS" \
          --quiet
          
    - name: üåê Get Service URL
      id: get_url
      run: |
        SERVICE_URL=$(gcloud run services describe ${{ needs.set-environment.outputs.service-name }} \
          --project=${{ env.PROJECT_ID }} \
          --region ${{ env.REGION }} \
          --format 'value(status.url)')
        echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
        
        # Create deployment summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## üöÄ Deployment Summary
        
        | Property | Value |
        |----------|-------|
        | **Environment** | ${{ needs.set-environment.outputs.environment }} |
        | **Service** | ${{ needs.set-environment.outputs.service-name }} |
        | **URL** | [$SERVICE_URL]($SERVICE_URL) |
        | **Image** | \`${{ github.sha }}\` |
        | **Deployed By** | @${{ github.actor }} |
        | **Timestamp** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |
        
        ### üîó Quick Links
        - [Health Check]($SERVICE_URL/health)
        - [API Docs]($SERVICE_URL/docs)
        - [Metrics]($SERVICE_URL/metrics)
        EOF

  # ========================================
  # 4. Post-Deployment Verification
  # ========================================
  verify:
    name: ‚úÖ Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy, set-environment]
    if: github.event_name == 'push'
    steps:
    - name: üè• Health Check
      run: |
        SERVICE_URL="${{ needs.deploy.outputs.service_url }}"
        echo "üîç Checking service health at $SERVICE_URL"
        
        # Wait for service to stabilize
        sleep 20
        
        # Advanced health check with retries
        MAX_RETRIES=10
        RETRY_DELAY=10
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i/$MAX_RETRIES..."
          
          # Check health endpoint
          if curl -sf --max-time 10 "$SERVICE_URL/health" > /dev/null; then
            echo "‚úÖ Health check passed!"
            
            # Additional smoke tests for production
            if [[ "${{ needs.set-environment.outputs.environment }}" == "production" ]]; then
              echo "üîç Running production smoke tests..."
              
              # Check API status
              curl -sf "$SERVICE_URL/api/v1/status" || echo "‚ö†Ô∏è Status endpoint check failed"
              
              # Check metrics endpoint
              curl -sf "$SERVICE_URL/metrics" || echo "‚ö†Ô∏è Metrics endpoint check failed"
            fi
            
            exit 0
          fi
          
          if [ $i -lt $MAX_RETRIES ]; then
            echo "‚è≥ Waiting ${RETRY_DELAY}s before retry..."
            sleep $RETRY_DELAY
          fi
        done
        
        echo "‚ùå Health check failed after $MAX_RETRIES attempts"
        exit 1

  # ========================================
  # 5. Cleanup Ephemeral Environments
  # ========================================
  cleanup:
    name: üßπ Cleanup Environment
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'delete' || 
      (github.event_name == 'pull_request' && github.event.action == 'closed')
    steps:
    - name: üîê Google Cloud Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: ‚öôÔ∏è Setup Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      
    - name: üßπ Delete Cloud Run Service
      run: |
        # Determine service name based on event type
        if [[ "${{ github.event_name }}" == "delete" ]]; then
          BRANCH_NAME=$(echo "${{ github.event.ref }}" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c1-40)
          SERVICE_NAME="todo-api-dev-${BRANCH_NAME}"
        else
          # PR closed
          SERVICE_NAME="todo-api-pr-${{ github.event.pull_request.number }}"
        fi
        
        echo "üßπ Attempting to delete service: $SERVICE_NAME"
        
        # Delete the service (ignore errors if it doesn't exist)
        gcloud run services delete $SERVICE_NAME \
          --project=${{ env.PROJECT_ID }} \
          --region=${{ env.REGION }} \
          --quiet || echo "‚ÑπÔ∏è Service not found or already deleted"
        
        # Clean up associated container images
        echo "üßπ Cleaning up container images..."
        IMAGE_NAME="${{ env.DOCKER_REGISTRY }}/${{ env.PROJECT_ID }}/$SERVICE_NAME"
        gcloud container images delete $IMAGE_NAME --quiet --force-delete-tags || true
        
        echo "‚úÖ Cleanup completed"

  # ========================================
  # 6. Notification (Optional)
  # ========================================
  notify:
    name: üì¢ Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy, verify, set-environment]
    if: always() && github.event_name == 'push' && needs.set-environment.outputs.environment == 'production'
    steps:
    - name: üìä Deployment Status
      run: |
        if [[ "${{ needs.verify.result }}" == "success" ]]; then
          STATUS="‚úÖ SUCCESS"
          COLOR="28a745"
        else
          STATUS="‚ùå FAILED"
          COLOR="dc3545"
        fi
        
        # Add notification logic here (Slack, Discord, email, etc.)
        echo "Deployment Status: $STATUS"
        echo "Environment: ${{ needs.set-environment.outputs.environment }}"
        echo "URL: ${{ needs.deploy.outputs.service_url }}"